---
title: "Frequencies"
output:  
  html_document:  
    toc: true   
    toc_depth: 2  
    toc_float: true
toc-title: "Table of Contents"
---

# Set up

```{r packages, collapse=TRUE}
library(gtsummary)
library(tidyverse)
library(srvyr)
library(flextable)
library(officer)
library(labelled)
library(rlang)
```

<br>

Typical theme for gtsummary()

```{r set theme}

# For all I use the compact theme.
theme_gtsummary_compact()

```

<br>

Load Round 10 UK European Social Survey dataset. 

```{r}

ddir <- "/Users/joecrowley/R/Tables/gtsummary"
load(paste0(ddir,"/ESS_UK_snippet_Round 10.RData"))
glimpse(ess10)
look_for(ess10, details = "none")

ess10 <- ess10 %>% 
  mutate(across(all_of(c("lrscale","atchctr","psppsgva","hincfel")), ~fct_drop(.x))) 

ess10 <- ess10 %>% mutate(age3 = case_when(agea <= 34 ~ 1, agea <= 54 ~ 2, agea > 54 ~ 3)) %>% 
  mutate(age3 = factor(age3, levels = c(1,2,3), labels = c("15-34", "35-54", "54+")))
ess10 %>% count(agea)
ess10 %>% count(age3)
var_label(ess10$age3) <- "Age"

svy_df <- ess10 %>% as_survey_design(weights = anweight)

# List all .R files in ddir 
file_paths <- list.files(path = ddir, pattern = "\\.R$", full.names = TRUE, all.files = T) %>% 
  map_chr(., ~str_remove(.x, ddir)) %>% 
  grep("_interim", ., value =T, invert = T) # Drop interim functions, not used.

# Set of functions to be loaded. 
file_paths


# Load all functions (make sure no other .R files in this location)
map(file_paths, ~source(paste0(ddir,.x)))



```

<br>

```{r}

# why is the code below only returning percentages with decimals within the confidence interval?

totals <- function(
    data, # a dataframe
    variables_int, # a vector of variable names (prefers, perhaps requires, factors)
    crossbreak = NULL, # character vector - length 1
    stats_cat_int = "{p}", # character vector for categorical variables
    stats_num_int = "{mean}", # character vector for numeric variables
    ci_int = NULL, # if TRUE then add confidence intervals
    # number of digits for continuous variables, 
    # must be length 1 or same length as number of numeric variables
    num_digits_int = 2, 
    # Can only set split_num_int to TRUE if ci = NULL
    split_num_int = F, # set to TRUE to split continuous variables stats over multiple lines
    sig_int = NULL
    ) { 

  if(is.null(ci_int)){
    num_type <- ifelse(split_num_int == T, "continuous2", "continuous")
    stats_num_int2 <- if(split_num_int == T){stats_num_int} else{paste0(stats_num_int, collapse = " ")}
  } else {
    num_type <- "continuous"
    stats_num_int2 <- paste0(stats_num_int, collapse = " ")
  }
  
  if(!is.null(crossbreak)){
    for(i in 1:length(variables_int)){
      
        base_name <- paste0("base_size",i)
        o_lab <- paste0(var_label(data[variables_int[i]], null_action = "fill"))
        data <- data %>% mutate(!!base_name := case_when(
          is.na(across(all_of(crossbreak))) ~ NA, 
          is.na(across(all_of(variables_int[i]))) ~ NA, 
          TRUE ~ o_lab), 
          across(all_of(crossbreak), ~fct_drop(.x))
        )
        
        var_label(data[[base_name]]) <- ""
    }
    
    var_label(data[["base_size1"]]) <- "Unweighted sample sizes"
    base_names <- paste0("base_size",1:length(variables_int))
    
    crossbreak_var <- rlang::sym(crossbreak)
  
  } else {
    crossbreak_var <- NULL
  }

  table <- 
   data %>% 
    tbl_summary(
          type = all_continuous() ~ num_type,
          include = all_of(variables_int), 
          by = crossbreak_var,
          missing = "no", 
          statistic = list(
            all_categorical() ~ stats_cat_int, 
            all_continuous() ~ stats_num_int2
            ), 
          digits = list(
            all_categorical() ~ 1, 
            all_continuous() ~ num_digits_int
            )
   ) %>% 
    modify_header(
     all_stat_cols() ~ "**{level}**", 
     label ~ "**Variable**"
     ) %>% 
   bold_labels() %>% 
   add_stat_label(location = "column")
  
  if(is.null(crossbreak)){
    table <- table %>% add_n(last=TRUE)
  } else {
    table <- table %>% add_overall(last=F) %>%
       modify_header(stat_0 ~ "**Total**")
  }
 
 if (!is.null(ci_int)){
   
   table <- table %>% add_ci(statistic = 
     list(
      all_categorical() ~ "{conf.low} - {conf.high}", 
      all_continuous() ~ "{conf.low} - {conf.high}"
     ),
     style_fun = list(
       all_categorical() ~ label_style_percent(digits = 0),
       all_continuous() ~ label_style_sigfig(scale = 1, digits = 2)
       )
   )   
 }
  
  
  if(!is.null(crossbreak)){
    
    base_of_table <- 
        data %>%
        tbl_summary(
          include = all_of(base_names), 
          by = crossbreak_var,
          missing = "no", 
          statistic = list(all_of(base_names) ~ "{n}"),
          digits = list(all_categorical() ~ 0)
        ) %>%
        add_overall(last=F) %>% # non-missing cases for each variable 
        modify_header(
         all_stat_cols() ~ "**{level}**", 
         label ~ "**Variable**", 
         stat_0 ~ "**Total**"
         ) %>%
        bold_labels() 
    
    if(!is.null(sig_int)){table <- table %>% add_p()}
    
    table <- list(table, base_of_table) %>% tbl_stack() 
    
    table <- table %>%
            modify_spanning_header(
              all_stat_cols() ~ paste0("**",var_label(data[crossbreak]),"**"),
              # Added to ensure CI included in spanning headers
              starts_with("ci_stat") ~ paste0("**",var_label(data[crossbreak]),"**"),
              # suppress spanning header on total column
              ends_with("_0") ~ NA)   
    
    # Identify number of header row starting bases
    base_break_row <- which(table[["table_body"]] %>% pull(label) == "Unweighted sample sizes")
    
    # Remove label rows for bases after base 1.
    table <- table %>% modify_table_body(~.x %>%
        filter(!(grepl("base_size([2-9]|[1-9][0-9]|100)", variable, ignore.case = T) & label == "")) %>%
        add_row(.before = base_break_row) # Add break between bases and main table
    )
          
  }
  
  table <- table %>% modify_footnote(all_stat_cols() ~ NA) 
  
  return(table)
  
}

vars_to_use <- c("lrscale", "lrscale_num", "atchctr", "atchctr_num", "psppsgva", "psppsgva_num", "hincfel")
totals(data = ess10, 
       variables_int = vars_to_use,
       ci_int = T
       ) 

totals(data = ess10, 
       variables_int = vars_to_use,
       crossbreak = "gndr",
       ci_int = T, 
       sig_int = T
       ) 

totals(data = ess10, 
       variables_int = vars_to_use, 
       stats_cat_int = "{p} [{n}]",
       ci_int = T
       ) 

totals(data = ess10, 
       variables_int = vars_to_use, 
       stats_num_int = "{mean} ({sd})",
       num_digits_int = c(2, 1),
       ci_int = T
       ) 

totals(data = ess10, 
       variables_int = vars_to_use, 
       stats_num_int = c("{mean}", "({sd})"),
       num_digits_int = c(2, 1),
       split_num_int = F
       # ci_int = T
       ) 

totals(data = ess10, 
       variables_int = vars_to_use, 
       stats_cat_int = "{p}",
       stats_num_int = c("{mean}", "{median}", "({sd})", "{min}-{max}"),
       num_digits_int = c(2, 0, 1, 0 ,0),
       split_num_int = T
       # ci_int = T
       ) 

totals(data = ess10, 
       variables_int = vars_to_use, 
       stats_cat_int = "{p}",
       stats_num_int = c("{mean}", "{median}", "({sd})", "{min}-{max}"),
       num_digits_int = c(2, 0, 1, 0 ,0),
       split_num_int = F, 
       crossbreak = "gndr"
       # ci_int = T
       ) 

paste0(c("{mean}", "{median}", "({sd})", "{min}-{max}"), collapse = " ")

totals(data = ess10, 
       variables_int = vars_to_use, 
       crossbreak = c("gndr"),
       stats_cat_int = "{p}",
       stats_num_int = c("{mean}", "({sd})"),
       num_digits_int = c(2, 1),
       split_num_int = T, 
       ci_int = T
       ) 



```

<br>

```{r}

break_vars <- c("gndr", "age3")

cbreaks <- function(
    data, # dataframe
    variables,  # character vector
    crossbreaks = NULL, # character vector - length 1
    stats_cat = "{p}", # character vector for categorical variables
    stats_num = "{mean}", # character vector for numeric variables
    ci = NULL, # if TRUE then add confidence intervals
    # number of digits for continuous variables, 
    # must be length 1 or same length as number of numeric variables
    num_digits = 2, 
    # Can only set split_num to TRUE if ci = NULL
    split_num = F, # set to TRUE to split continuous variables stats over multiple lines
    sig = NULL, 
    caption = NULL,
    bases = NULL, # The object with base descriptions (from base_information() function)
    source = NULL, # A string describing the data source
    footnotes = NULL # Other character strings as footnotes, each on its own line. 
  ){
  
  if(is.null(crossbreaks)){crossbreaks <- list(NULL)}

  tables_int <- map(crossbreaks, ~data %>% totals(
      variables_int = variables, 
      crossbreak = .x, 
      stats_cat_int = stats_cat, 
      stats_num_int = stats_num, 
      ci_int = ci,
      num_digits_int = num_digits, 
      split_num_int = split_num,
      sig_int = sig
      )
    )

  if(length(tables_int) > 1){
    
    for(i in 2:length(tables_int)){
      
      tables_int[[i]] <- tables_int[[i]] %>% modify_table_body(~.x %>% select(!contains("stat_0")) %>% select(!contains("stat_label"))) 
      
    }
    
    variable_labels <- data %>% select(all_of(crossbreaks)) %>% var_label(unlist = T) %>% paste0("**", ., "**")
  
  tables <- tbl_merge(tables_int, tab_spanner = variable_labels) %>% 
    modify_spanning_header(contains("stat_label") ~ NA, contains("stat_0") ~ NA)
    
  } else {
    tables <- tables_int[[1]]
  }
  
  if(!is.null(crossbreaks)){
    variables <- c(variables, crossbreaks)
  }
  
  footnotes <- gtsummary_table_notes(
    bases_info = bases, 
    vars = variables, 
    source_note = source, 
    other_footnotes = footnotes
  )

  if (footnotes != ""){
    tables <- tables %>% modify_source_note(
    source_note = footnotes, 
    text_interpret = "html")
  }
  
  if(!is.null(caption)){
    tables <- tables %>% 
    modify_caption(paste0("<div style='text-align: left; font-weight: bold; color: black'>", caption,"</div>")) 
  }
  
  return(tables)

}

```


```{r}

totals_only <- 
  cbreaks(data = ess10, 
       variables = vars_to_use, 
       stats_cat = "{p}",
       stats_num = c("{mean}", "{median}", "({sd})", "{min}-{max}"),
       num_digits = c(2, 0, 1, 0 ,0),
       split_num = T, 
       caption = "Table 1: Descriptive statistics for selected variables from ESS Round 10", 
       source = "ESS", 
       footnotes = "Notes, various"
       ) 

totals_only

totals_only_ci <- 
  cbreaks(data = ess10, 
       variables = vars_to_use, 
       stats_cat = "{p}",
       stats_num = c("{mean}", "{median}", "({sd})", "{min}-{max}"),
       num_digits = c(2, 0, 1, 0 ,0),
       split_num = T, 
       ci = T,
       caption = "Table 1: Descriptive statistics for selected variables from ESS Round 10", 
       source = "ESS", 
       footnotes = "Notes, various"
       ) 

totals_only_ci

tbl <- cbreaks(data = ess10, 
       variables = vars_to_use, 
       crossbreaks = c("gndr", "age3"),
       stats_cat = "{p}",
       stats_num = c("{mean}", "({sd})"),
       num_digits = c(2, 1),
       split_num = T, 
       sig = T
       ) 

tbl

tbl_ci <- cbreaks(data = ess10, 
       variables = vars_to_use, 
       crossbreaks = c("gndr"),
       stats_cat = "{p}",
       stats_num = c("{mean}", "({sd})"),
       num_digits = c(2, 1),
       split_num = F, 
       ci = T
       ) 

tbl_ci

tbl_ci2 <- cbreaks(data = ess10, 
       variables = vars_to_use, 
       crossbreaks = c("gndr", "age3"),
       stats_cat = "{p}",
       stats_num = c("{mean}", "({sd})"),
       num_digits = c(2, 1),
       split_num = F, 
       ci = T
       ) 

tbl_ci2

```

# Make me a data frame

```{r}

totals_only[["table_body"]] %>% names()

totals_only_ci[["table_body"]] %>% names()

tbl[["table_body"]] %>% names

tbl_ci[["table_body"]] %>% names

tbl_ci2[["table_body"]] %>% names


# Identify number of crossbreaks in the table...
identify_number_of_crossbreaks_in_table <- function(tbl){
  
 whether_has_any_crossbreaks <- tbl[["table_body"]] %>% names() %>% 
  grep(., pattern = "stat_", value = T) %>%
  grep("stat_label", ., value = T, invert = T) %>% 
    length()
 
 if(whether_has_any_crossbreaks == 1){count_of_crossbreaks <- 0
  } else {
  
  suppressWarnings({
  count_of_crossbreaks <- 
    tbl[["table_body"]] %>% names %>%
    grep(., pattern = "stat_", value = T) %>% 
    grep("stat_label", ., value = T, invert = T) %>% 
    grep("ci_stat", ., value = T, invert = T) %>% 
    str_split_i(., "_", 3) %>% 
    unique %>% max(., na.rm = T)
  })
    
  }
  
  if(!sum(is.na(count_of_crossbreaks)) == 0){count_of_crossbreaks <- 1}
  
  return(as.numeric(count_of_crossbreaks))
  
}

identify_number_of_crossbreaks_in_table(totals_only)
identify_number_of_crossbreaks_in_table(tbl)
identify_number_of_crossbreaks_in_table(tbl_ci)

```

<br>

```{r}

split_tables_by_predictor <- function(tbl, number_of_predictors){
  
  if(number_of_predictors == 0){
    
    result <- list(tbl[["table_body"]] %>% 
      select(row_type, variable, var_label, label, stat_label, stat_0, contains("ci_stat_0"), n))
    
  } else if(number_of_predictors == 1){
    
    result <- list(tbl[["table_body"]] %>% 
      select(row_type, variable, var_label, label, contains("stat_label"), (contains("stat_"))))
    
  } else {
    
    result <- map(1:number_of_predictors, function(xxx){
      
      statistic_column_id <- paste0("_", xxx)
      
      tbl_result <- tbl[["table_body"]] %>% select(
        row_type, variable, var_label, label, contains("stat_label"), 
        starts_with("stat_0"),
        (contains("stat_") & ends_with(statistic_column_id)))
      
      return(tbl_result)
      
    })
  }
  
  return(result)
  
}

split_tables_by_predictor(tbl = totals_only, number_of_predictors = 0)

split_tables_by_predictor(tbl = tbl, number_of_predictors = 2)

split_tables_by_predictor(tbl = tbl_ci, number_of_predictors = identify_number_of_crossbreaks_in_table(tbl_ci))

tbl_ci2_list <- split_tables_by_predictor(
  tbl = tbl_ci2, 
  number_of_predictors = identify_number_of_crossbreaks_in_table(tbl_ci2)
  )

tbl_ci2_list[[1]]

```


<br>

# Split by variable

```{r}

tbl_ci2_list[[1]]

pivot_cbreak_table_longer <- function(tbl){

  (var_names <- tbl$variable %>% unique() %>% na.omit() %>% grep("base_size", ., value = T, invert = T))
  
  (base_var_names <- paste0("base_size", 1:length(var_names)))
  body_of_tables <- tbl %>% 
    filter(variable %in% var_names) %>% 
    filter(row_type=="level") %>% 
    select(-row_type) %>% 
    pivot_longer(
      cols = -c(1:4), 
      names_to = c("stat"),
      values_to = "value"
    ) %>%
    mutate(names = case_when(grepl("ci_", stat) ~ "CI", TRUE ~ "Est"), 
           stat = str_remove_all(stat, "ci_")) %>% 
    pivot_wider(names_from = names, values_from = value)
  
  body_of_tables
  
  base_of_tables <- tbl %>% filter(variable %in% base_var_names) %>% 
    filter(label != "Unweighted sample sizes") %>%
    select(label, starts_with("stat_")) %>% 
    select(-stat_label_1) %>% unique() %>% 
    pivot_longer(cols = -1, names_to = "stat", values_to = "Base size") %>% 
    rename(var_label=label)
  
  base_of_tables
  
  table <- full_join(body_of_tables, base_of_tables, join_by(var_label, stat)) 
  table
  
  return(table)

}

pivot_cbreak_table_longer(tbl = tbl_ci2_list[[2]])
pivot_cbreak_table_longer(tbl = split_tables_by_predictor(tbl = tbl, number_of_predictors = 2)[[1]])

totals_only_table <- split_tables_by_predictor(tbl = totals_only, number_of_predictors = 0)


pivot_totals_table_longer <- function(tbl){
  
  (var_names <- tbl$variable %>% unique() %>% na.omit()) 
   
  body_of_tables <- tbl %>% 
    filter(variable %in% var_names) %>% 
    filter(row_type=="level") %>% 
    select(-row_type, -n) 
  
  base_of_tables <- tbl %>% select(variable, n) %>% unique %>% drop_na()
  
  table <- full_join(body_of_tables, base_of_tables, join_by(variable)) %>% 
    rename(any_of(c(stat_label_1 = "stat_label", Est = "stat_0", CI = "ci_stat_0", `Base size` = "n"))) %>% 
    mutate(Level = "Total", .after = stat_label_1)
  
  return(table)
  
}

pivot_totals_table_longer(totals_only_table[[1]])

totals_only_ci_table <- split_tables_by_predictor(tbl = totals_only_ci, number_of_predictors = 0)

pivot_totals_table_longer(totals_only_ci_table[[1]])

```


```{r}

tbl[["table_styling"]]

tbl[["table_styling"]][["spanning_header"]][["spanning_header"]] %>% unique %>% na.omit() %>% str_replace_all(., "\\*","")

map(1:length(tbl[["tbls"]]), ~tbl[["tbls"]][[.x]][["table_styling"]][["spanning_header"]][["spanning_header"]] %>% unique %>% na.omit() %>% str_replace_all(., "\\*","")) %>% unlist

make_df <- function(tbl){
  
  current_names <- tbl[["table_body"]] %>% names
  names(current_names) <- tbl[["table_styling"]][["header"]][["label"]] %>% str_replace_all(., "\\*", "")
  current_names <- current_names %>% grep("stat_", ., value = T) %>% grep("stat_label|ci_stat", ., value = T, invert = T) 
  
  number_of_crossbreaks_in_table <- identify_number_of_crossbreaks_in_table(tbl)
  
  tables_split_by_predictor <- split_tables_by_predictor(tbl = tbl, number_of_predictors = number_of_crossbreaks_in_table)

  if(number_of_crossbreaks_in_table > 0){
    
    predictor_labels <- map(1:length(tbl[["tbls"]]), 
      ~tbl[["tbls"]][[.x]][["table_styling"]][["spanning_header"]][["spanning_header"]] %>% 
        unique %>% 
        na.omit() %>% 
        str_replace_all(., "\\*","")) %>% 
        unlist
    
    map2(tables_split_by_predictor, predictor_labels, ~pivot_cbreak_table_longer(.x) %>%
          mutate(stat = factor(stat)) %>%
          mutate(stat = fct_recode(stat, !!!current_names)) %>% 
          rename(plevel = stat) %>% 
          mutate(Predictor = .y) %>% 
          relocate(Predictor, plevel)
    )
    
  } else {
    
    map(tables_split_by_predictor, ~pivot_totals_table_longer(.x))
    
  }
  
}

make_df(tbl_ci2)  
make_df(tbl_ci2)[[1]]$stat %>% levels
make_df(tbl_ci2)[[2]]$stat %>% levels
make_df(totals_only)
make_df(tbl)

```




