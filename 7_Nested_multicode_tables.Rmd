---
title: "Multicodes"
output: 
  html_document:  
    toc: true   
    toc_depth: 2  
    toc_float: true
toc-title: "Table of Contents"
---

# Set up

```{r packages, collapse=TRUE}
library(gtsummary)
library(tidyverse)
library(srvyr)
library(flextable)
library(officer)
library(labelled)
library(rlang)
```

<br>

Typical theme for gtsummary()

```{r set theme}

# For all I use the compact theme.
theme_gtsummary_compact()

```

<br>

Load Round 10 UK European Social Survey dataset. 

```{r}

ddir <- paste0(getwd())
load(paste0(ddir,"/ESS_UK_snippet_Round 10.RData"))
glimpse(ess10)

svy_df <- ess10 %>% as_survey_design(weights = anweight)

# List all .R files in ddir 
file_paths <- list.files(path = ddir, pattern = "\\.R$", full.names = TRUE, all.files = T) %>% 
  map_chr(., ~str_remove(.x, ddir)) %>% 
  grep("_interim", ., value =T, invert = T) # Drop interim functions, not used.

# Set of functions to be loaded. 
file_paths
```

<br>

## Load functions
```{r, results='hide'}

# Load all functions (make sure no other .R files in this location)
map(file_paths, ~source(paste0(ddir,.x)))

```

<br>

# Load additional binary data

<br>

The code below loads some additional data, for use in multicoded tables. 

```{r}

load("/Users/joecrowley/R/Data/ESS_UK/ESS_UK_R_data_file.RData")

# Use set of variables on location people can access internet from
ess %>% select(starts_with("acc")) %>% map_df(.,var_label) %>% pivot_longer(cols = everything())

# Identify variable names
int_loc <- ess %>% select(starts_with("acc")) %>% names
int_loc <- int_loc[3:10]
int_loc

ess %>% select(all_of(int_loc)) %>% map_df(.,var_label) %>% pivot_longer(cols = everything())

ess10 %>% select(ctzcntr, brncntr,feethngr) %>% look_for() %>% convert_list_columns_to_character() %>% flextable

```

<br><br>

# Overview of process

**Some checks**   

 -  all have same base size?
 -  contains splitter in variable labels? (: )  
 -  not contains multiple splitters. 
 
**Steps**. 

1. Checks above,  
2. Relabel variables, store stem
3. Create unweighted base variable,  
4. Create vector of variables to use, 
5. Create table,
6. Optional, add caption, 
7. Optional, add CI. 

```{r vars for simple multicode}

ess %>% select(all_of(int_loc)) %>% look_for(details = "none")

```

<br> 

# Data set up

These functions are just going to expect well managed data. 

You can provide variables which are either:  

- yes / no.  
- 0 / 1.  
- TRUE / FALSE   

All variables **must** have those levels, even if not observed for a particular variable. 

```{r data management}

# Variables must be factors, drop unused levels..
ess3 <- ess %>% 
  mutate(across(all_of(int_loc), ~fct_drop(to_factor(.x))))

# gtsummary expects yes/no, 0/1 or TRUE/FALSE for dichotomous variables
ess3$acchome %>% levels # we have 'Not marked' / 'Marked'
ess3 <- ess3 %>% 
  mutate(across(all_of(int_loc), ~fct_recode(.x, 
        "Yes" = "Marked", "No" = "Not marked")))

ess3$acchome %>% levels

# Note they do all need to have the two levels...
# When adding factor levels remember to use forcats to preserve variable labels
# If done with factor() variable labels will be dropped. 
ess3 %>% select(all_of(int_loc)) %>% map(., levels)
ess3 <- ess3 %>% mutate(across(all_of(int_loc), ~fct_expand(.x, c("Yes", "No")))) 
ess3 %>%  select(all_of(int_loc)) %>% map(., levels)

var_label(ess %>% select(all_of(int_loc)))

# Age
ess3 %>% count(age)
sum(is.na(ess3$age))

ess3 <- ess3 %>% mutate(age30 = fct_drop(to_factor(ageyo30)))
ess3 %>% count(age30)

# Gender
ess3 %>% count(gndr)
sum(is.na(ess3$gndr))

ess3 <- ess3 %>% mutate(gndr2 = fct_drop(to_factor(gndr)))
ess3 %>% count(gndr2)

# Ethnicity
ess3 %>% select(contains("pray"))
ess3 <- ess3 %>% mutate(pray2 = fct_drop(to_factor(pray)))
ess3 %>% count(pray2)

# Multicodes
svy_df <- ess3 %>% filter(!is.na(anweight)) %>% as_survey_design(weights = anweight)

```

<br>

# The main function

Applying the function itself. 

```{r simple multicode tables function}

nest_multicodes <- function(
    df, # data frame 
    vars, # vars
    ci = FALSE, # Confidence intervals, set to TRUE
    caption = NULL, # Replace with caption string
    breaks = NULL, # character vector of crossbreaks
    sig = F, 
    nest = NULL,
    bases = NULL, # The object with base descriptions (from base_information() function)
    source = NULL, # A string describing the data source
    footnotes = NULL # Other character strings as footnotes, each on its own line.
) {
  
  # For nested table, define additional bits to add to table
  if(ci == F & sig == F){
  
  appendages <- function(x){x}
  
  } else if (ci == F & sig == T){
    
      appendages <- function(x){x %>% add_p(include = !all_of("unweighted_base"))}
      
  } else if (ci == T & sig == T){
    
        appendages <- function(x){x %>% 
            add_p(include = !all_of("unweighted_base")) %>% 
            add_ci(
             include = -unweighted_base,
             statistic = list(all_categorical() ~ "[{conf.low} - {conf.high}]"),
             style_fun = all_categorical() ~ label_style_sigfig(scale = 100, digits = 1)
             )
          }
        
        } else if (ci == T & sig == F){
    
        appendages <- function(x){x %>% 
            add_ci(
             include = -unweighted_base,
             statistic = list(all_categorical() ~ "[{conf.low} - {conf.high}]"),
             style_fun = all_categorical() ~ label_style_sigfig(scale = 100, digits = 1)
             )
          }
  }
  
  # Check whether survey data or not (T = survey; F = data frame)
  whether_survey_data <- if(
     class(df) %>% 
      grep("survey.design", ., value = T) %>% 
      length() > 0
  ){T} else {F}
  
  # Create object that is always the data frame, not a survey design object
  dataset_reference <- if(whether_survey_data == F){df} else {df[["variables"]]}
  
  # Check variable labels contain ": " and that the base of each variable is equal
  chk1 <- splitter_present(dataset_reference, vars)
  chk2 <- bases_equal(dataset_reference, vars)
  
  # If both checks are TRUE create table
  if (chk1 == TRUE & chk2 == TRUE) {

  # Add variable reflecting number of non-missing cases
  dataset_reference <- dataset_reference %>% 
    mutate(unweighted_base = case_when(
      !is.na(df %>% pull(vars[1])) ~ "Unweighted bases", 
      TRUE ~ NA)
      )
  var_label(dataset_reference$unweighted_base) <- ""

  # Add unweighted base variable to vector of outcomes
  var_set <- c(vars, "unweighted_base")
  
  # Extract variable labels
  variable_label_stem <- dataset_reference %>% pull(vars[1]) %>% var_label() %>% str_split_i(., ": ", 1)

  # Remove stem from variable labels
  dataset_reference <- revise_labels(dataset_reference, vars = vars)
  
  # Put data back into original object
  if(whether_survey_data == T){
    df2 <- df
    df2[["variables"]] <- dataset_reference
  } else {
    df2 <- dataset_reference
  }
  
  # Choose gtsummary function to use
  if(whether_survey_data == T){summary_fun <- tbl_svysummary} else {summary_fun <- tbl_summary}
  
  # Define base size statistic to use
  if(whether_survey_data == T){n_statistic <- "{n_unweighted}"} else {n_statistic <- "{n}"}
  
  # Create table
  tbl <- df2 %>%
    summary_fun(
      include = all_of(var_set),
      type = list(unweighted_base ~ "categorical"),
      missing = "no", 
      statistic = list(all_dichotomous() ~ "{p}", 
                        all_categorical() ~ "{p}",
                        unweighted_base ~ n_statistic), 
      digits = list(all_dichotomous() ~ 1)
    ) %>% 
    modify_header(all_stat_cols() ~ "**Total**")
  
  # Confidence intervals. 
  if (ci == TRUE) {
    tbl <- tbl %>% 
      add_ci(
       include = -unweighted_base,
       statistic = list(all_categorical() ~ "[{conf.low} - {conf.high}]"),
       style_fun = all_categorical() ~ label_style_sigfig(scale = 100, digits = 1)
       )
  }
  
    suppressWarnings({suppressMessages({
    
     brk_tbl <- 
        df2 %>%
          filter(!is.na(.data[[breaks]])) %>%
          summary_fun(
            include = all_of(var_set),
            by = all_of(breaks),
            type = list(unweighted_base ~ "categorical"),
            missing = "no", 
            statistic = list(all_dichotomous() ~ "{p}", 
                              all_categorical() ~ "{p}",
                              unweighted_base ~ n_statistic), 
            digits = list(all_dichotomous() ~ 1)
          )
  
    if(sig == TRUE){
      
      brk_tbl <- brk_tbl %>% 
          add_p(include = !all_of("unweighted_base"))
        
    } 
     
    # Confidence intervals. 
    if (ci == TRUE) {
      brk_tbl <- brk_tbl %>% 
          add_ci(
           include = -unweighted_base,
           statistic = list(all_categorical() ~ "[{conf.low} - {conf.high}]"),
           style_fun = all_categorical() ~ label_style_sigfig(scale = 100, digits = 1)
           )
    }
     
    brk_tbl <- brk_tbl %>% modify_spanning_header(
            all_stat_cols() ~ paste0("**",var_label(dataset_reference[breaks])," (overall)**"),
            # Added to ensure CI + p.value included in spanning headers
            starts_with("ci_stat") | contains("p.value") ~ paste0("**",var_label(dataset_reference[breaks])," (overall)**"), 
            ) 
     
     nest_tbl <- 
        df2 %>%
          filter(!is.na(.data[[breaks]]) & !is.na(.data[[nest]])) %>%
           tbl_strata(strata = {{nest}}, 
               ~.x %>% summary_fun(
                  include = all_of(var_set),
                  by = all_of(breaks),
                  type = list(unweighted_base ~ "categorical"),
                  missing = "no", 
                  statistic = list(all_dichotomous() ~ "{p}", 
                                    all_categorical() ~ "{p}",
                                    unweighted_base ~ n_statistic), 
                  digits = list(all_dichotomous() ~ 1)
                ) %>% 
                appendages(), 
             .header = "**{strata}**"
           )

  })})
    
  # Combine table components
  tbl <- list(tbl, brk_tbl, nest_tbl) %>% tbl_merge(tab_spanner = FALSE)
  
  # Edit caption when caption is missing
  if(is.null(caption)){
   caption <- paste0("<div style='text-align: left; font-weight: bold; color: black'>",
                 "Crosstabulation by ", 
                 var_label(dataset_reference[[breaks]]),
                 ", nested by ", 
                 var_label(dataset_reference[[nest]]),
                 ".",
                 "</div>")
  } else {
    caption <- paste0("<div style='text-align: left; font-weight: bold; color: black'>", caption,"</div>",
                "<div style='text-align: left; font-style: italic; color: black'>","<br>Crosstabulation by ", 
                 var_label(dataset_reference[[breaks]]),
                 ", nested by ", 
                 var_label(dataset_reference[[nest]]),
                 ".</div>")
  }
  
  tbl <- tbl %>%
    
    # Set headers
    modify_header(all_stat_cols() ~ "**{level}**", 
                  label ~ paste0("**",variable_label_stem,"**"), 
                  # stat_0 ~ "**%**"
                  ) %>% 
    
    # Add a caption
    modify_caption(caption)
  
    # Footnote - whether weighted or unweighted
    if(whether_survey_data == T){
           stat_types <- "All statistics shown in this table are weighted."
         } else {stat_types <- "All statistics shown in this table are unweighted."
      }

    tbl <- tbl %>%
      modify_footnote(all_stat_cols() ~ NA) %>% # Suppress standard footnotes
      modify_footnote_header(columns = "label", stat_types, replace = F)

  # Base notes, foot notes, source notes
  bases_variables <- c("multicode_labels", breaks, nest)
  
  if(!is.null(bases)) {
      
      description_of_multicode_variables <- bases[[2]] %>% unique
      names(description_of_multicode_variables) <- "multicode_labels"
      label_of_multicode_variables <- variable_label_stem
      names(label_of_multicode_variables) <- "multicode_labels"

      bases[[2]] <- c(bases[[2]], description_of_multicode_variables)
      bases[[3]] <- c(bases[[3]], label_of_multicode_variables)
      bases[[4]] <- c(bases[[4]], label_of_multicode_variables)
      
  } 
  
  footnotes <- gtsummary_table_notes(
    bases_info = bases, 
    vars = bases_variables, 
    source_note = source, 
    other_footnotes = footnotes
  )
  
  # Add any footnotes to table
  if (footnotes != ""){
    tbl <- tbl %>% modify_source_note(
    source_note = footnotes, 
    text_interpret = "html")
  }
  
  return(tbl)

  } else {
    
    helpful_error_message <- paste0("Not working: chk1 = ", chk1,", chk2 = ", chk2)
    return(helpful_error_message)
    
  }

}

writeLines(
  c("nest_multicodes <- ", # Assignment needs to be added manually
  deparse(nest_multicodes)), # Extract function code
  paste0(ddir,"/nest_multicodes.R")) # File name is just the function name 

```

<br> 

# Examples

## Example 1

```{r}

ess3["pray2"] %>% var_label

nest_multicodes(df = ess3, vars = int_loc, breaks = "pray2", nest = "gndr2", source = "European Social Survey")

```

<br> 

# Applying base size arguments

```{r}

int_loc

var_descriptions <- rep("Asked of all respondents as well, but with a separate label for testing", 8)
names(var_descriptions) <- int_loc
var_descriptions

example_of_base_information <- base_information(
  data = ess3,
  general_base = "Asked of all respondents", 
  specific_bases = var_descriptions
)

map(example_of_base_information, head)

nest_multicodes(df = ess3, vars = int_loc, breaks = c("gndr2"), nest = "pray2", ci = F, bases = example_of_base_information)

```





