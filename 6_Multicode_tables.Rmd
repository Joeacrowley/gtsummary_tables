---
title: "Multicodes"
output: 
  html_document:  
    toc: true   
    toc_depth: 2  
    toc_float: true
toc-title: "Table of Contents"
---

# Set up

```{r packages, collapse=TRUE}
library(gtsummary)
library(tidyverse)
library(srvyr)
library(flextable)
library(officer)
library(labelled)
library(rlang)
```

<br>

Typical theme for gtsummary()

```{r set theme}

# For all I use the compact theme.
theme_gtsummary_compact()

```

<br>

Load Round 10 UK European Social Survey dataset. 

```{r}

ddir <- paste0(getwd())
load(paste0(ddir,"/ESS_UK_snippet_Round 10.RData"))
glimpse(ess10)

svy_df <- ess10 %>% as_survey_design(weights = anweight)

# List all .R files in ddir 
file_paths <- list.files(path = ddir, pattern = "\\.R$", full.names = TRUE, all.files = T) %>% 
  map_chr(., ~str_remove(.x, ddir)) %>% 
  grep("_interim", ., value =T, invert = T) # Drop interim functions, not used.

# Set of functions to be loaded. 
file_paths
```

<br>

## Load functions
```{r, results='hide'}

# Load all functions (make sure no other .R files in this location)
map(file_paths, ~source(paste0(ddir,.x)))

```

<br>

## Load additional binary data

The code below loads some additional data, for use in multicoded tables. 

```{r}

load("/Users/joecrowley/R/Data/ESS_UK/ESS_UK_R_data_file.RData")

# Use set of variables on location people can access internet from
ess %>% select(starts_with("acc")) %>% map_df(.,var_label) %>% pivot_longer(cols = everything())

# Identify variable names
int_loc <- ess %>% select(starts_with("acc")) %>% names
int_loc <- int_loc[3:10]
int_loc

ess %>% select(all_of(int_loc)) %>% map_df(.,var_label) %>% pivot_longer(cols = everything())

ess10 %>% select(ctzcntr, brncntr,feethngr) %>% look_for() %>% convert_list_columns_to_character() %>% flextable

```

<br><br>

# Overview of process

**Some checks**   

 -  all have same base size?
 -  contains splitter in variable labels? (: )  
 -  not contains multiple splitters. 
 
**Steps**. 

1. Checks above,  
2. Relabel variables, store stem
3. Create unweighted base variable,  
4. Create vector of variables to use, 
5. Create table,
6. Optional, add caption, 
7. Optional, add CI. 

### Proposed variables testing multicodes

```{r vars for simple multicode}

ess %>% select(all_of(int_loc)) %>% look_for(details = "none")

```

<br> 

# Checks

## Bases equal

```{r check all variables have same base size}

unique_base_sizes <- 
  ess %>% 
  select(all_of(int_loc)) %>% 
  map_int(., ~sum(is.na(.x))) %>% 
  unique()

unique_base_sizes

length(unique_base_sizes) == 1

# As function, returns TRUE if equal

bases_equal <- function(
    df, # data frame
    vars # character vector of variables
    ) {
  
  unique_base_sizes <- 
  df %>% 
  select(all_of(vars)) %>% 
  map_int(., ~sum(is.na(.x))) %>% 
  unique()

unique_base_sizes

result <- length(unique_base_sizes) == 1

return(result)

}

bases_equal(ess, int_loc)

writeLines(
  c("bases_equal <- ", # Assignment needs to be added manually
  deparse(bases_equal)), # Extract function code
  paste0(ddir,"/bases_equal.R")) # File name is just the function name 


```

<br> 

## Labels contain splitter

I combine checks 2 and 3 in the below

```{r check all variable labels contain splitter}

labels_contain_splitter <- 
  ess %>% 
  select(all_of(int_loc)) %>%
  var_label(unlist = T, null_action = "fill") %>% 
  map_int(., ~str_count(.x, ": "))

labels_contain_splitter

# Check each label contains the splitter
length(labels_contain_splitter) == sum(labels_contain_splitter)

# Check no label contains the splitter more than once
max(labels_contain_splitter) == 1

# As a function, returns TRUE if all contain splitter
splitter_present <- function(
    df, 
    vars) { 
  
  labels_contain_splitter <- 
    df %>% 
    select(all_of(vars)) %>%
    var_label(unlist = T, null_action = "fill") %>% 
    map_int(., ~str_count(.x, ": "))

  labels_contain_splitter
  
  # Check each label contains the splitter, returns TRUE if they do
  all_contain_splitter <- length(labels_contain_splitter) == sum(labels_contain_splitter)
  
  # Check no label contains the splitter more than once, returns TRUE all equal 1
  splitter_appears_once_each <- max(labels_contain_splitter) == 1
  
  # result is TRUE if both statements equal true. 
  result <- all_contain_splitter == TRUE & splitter_appears_once_each == TRUE
  return(result)

}

splitter_present(ess, int_loc)

writeLines(
  c("splitter_present <- ", # Assignment needs to be added manually
  deparse(splitter_present)), # Extract function code
  paste0(ddir,"/splitter_present.R")) # File name is just the function name 

```

<br> 

## Split variable labels and store stem

```{r split variable labels and store stem}

# Testing data frame
ess2 <- ess

# Create a list containing the revised variables
revised_labels_as_list <- 
  map(int_loc, function(xxx) { 
  variable_label <- ess %>% select(all_of(xxx)) %>% var_label %>% str_split_i(., ": ", 2)
  return(variable_label)
}) 
names(revised_labels_as_list) <- int_loc # add names

# Revise variable labels
var_label(ess2) <- revised_labels_as_list

# Review corrected labels...
ess2 %>% 
  select(all_of(int_loc)) %>%
  var_label(unlist = T, null_action = "fill")

# Extract stem - I won't make this a function, it's very simple.
ess %>% pull(int_loc[1]) %>% var_label() %>% str_split_i(., ": ", 1)


# As a function - returns relabelled data frame... 
revise_labels <- function(
    df, # data frame
    vars # character vector of variable names
    ) {
  
  # Create a list containing the revised variables
  revised_labels_as_list <- 
    map(vars, function(xxx) { 
    variable_label <- df %>% select(all_of(xxx)) %>% var_label %>% str_split_i(., ": ", 2)
    return(variable_label)
  }) 
  names(revised_labels_as_list) <- vars # add names

  # Revise variable labels
  var_label(df) <- revised_labels_as_list
  return(df)
  
}

# Apply function
ess2 <- revise_labels(ess, int_loc)

# Review corrected labels...
ess2 %>% 
  select(all_of(int_loc)) %>%
  var_label(unlist = T, null_action = "fill")

writeLines(
  c("revise_labels <- ", # Assignment needs to be added manually
  deparse(revise_labels)), # Extract function code
  paste0(ddir,"/revise_labels.R")) # File name is just the function name 

```

<br> 

# Data set up

These functions are going to expect well managed data. 

You can provide variables which are either:  

- yes / no.  
- 0 / 1.  
- TRUE / FALSE   

All variables **must** have those levels, even if not observed for a particular variable. 

```{r data management}

# Variables must be factors, drop unused levels..
ess3 <- ess %>% 
  mutate(across(all_of(int_loc), ~fct_drop(to_factor(.x))))

# gtsummary expects yes/no, 0/1 or TRUE/FALSE for dichotomous variables
ess3$acchome %>% levels # we have 'Not marked' / 'Marked'
ess3 <- ess3 %>% 
  mutate(across(all_of(int_loc), ~fct_recode(.x, 
        "Yes" = "Marked", "No" = "Not marked")))

ess3$acchome %>% levels

# Note they do all need to have the two levels...
# When adding factor levels remember to use forcats to preserve variable labels
# If done with factor() variable labels will be dropped. 
ess3 %>% select(all_of(int_loc)) %>% map(., levels)
ess3 <- ess3 %>% mutate(across(all_of(int_loc), ~fct_expand(.x, c("Yes", "No")))) 
ess3 %>%  select(all_of(int_loc)) %>% map(., levels)

var_label(ess %>% select(all_of(int_loc)))

# Age
ess3 %>% count(age)
sum(is.na(ess3$age))

ess3 <- ess3 %>% mutate(age30 = fct_drop(to_factor(ageyo30)))
ess3 %>% count(age30)

# Gender
ess3 %>% count(gndr)
sum(is.na(ess3$gndr))

ess3 <- ess3 %>% mutate(gndr2 = fct_drop(to_factor(gndr)))
ess3 %>% count(gndr2)

# Ethnicity
ess3 %>% select(contains("pray"))
ess3 <- ess3 %>% mutate(pray2 = fct_drop(to_factor(pray)))
ess3 %>% count(pray2)

# Multicodes
svy_df <- ess3 %>% filter(!is.na(anweight)) %>% as_survey_design(weights = anweight)

```

<br>

# The main function

Applying the function itself. 

```{r simple multicode tables function}

multicodes <- function(
    df, # data frame 
    vars, # vars
    ci = FALSE, # Confidence intervals, set to TRUE
    caption = NULL, # Replace with caption string
    breaks = NULL, # character vector of crossbreaks
    sig = F, 
    bases = NULL, # The object with base descriptions (from base_information() function)
    source = NULL, # A string describing the data source
    footnotes = NULL # Other character strings as footnotes, each on its own line.
) {
  
  # Check whether survey data or not (T = survey; F = data frame)
  whether_survey_data <- if(
     class(df) %>% 
      grep("survey.design", ., value = T) %>% 
      length() > 0
  ){T} else {F}
  
  # Create object that is always the data frame, not a survey design object
  dataset_reference <- if(whether_survey_data == F){df} else {df[["variables"]]}
  
  # Check variable labels contain ": " and that the base of each variable is equal
  chk1 <- splitter_present(dataset_reference, vars)
  chk2 <- bases_equal(dataset_reference, vars)
  
  # If both checks are TRUE create table
  if (chk1 == TRUE & chk2 == TRUE) {

  # Add variable reflecting number of non-missing cases
  dataset_reference <- dataset_reference %>% 
    mutate(unweighted_base = case_when(
      !is.na(df %>% pull(vars[1])) ~ "Unweighted bases", 
      TRUE ~ NA)
      )
  var_label(dataset_reference$unweighted_base) <- ""

  # Add unweighted base variable to vector of outcomes
  var_set <- c(vars, "unweighted_base")
  
  # Extract variable labels
  variable_label_stem <- dataset_reference %>% pull(vars[1]) %>% var_label() %>% str_split_i(., ": ", 1)

  # Remove stem from variable labels
  dataset_reference <- revise_labels(dataset_reference, vars = vars)
  
  # Put data back into original object
  if(whether_survey_data == T){
    df2 <- df
    df2[["variables"]] <- dataset_reference
  } else {
    df2 <- dataset_reference
  }
  
  # Choose gtsummary function to use
  if(whether_survey_data == T){summary_fun <- tbl_svysummary} else {summary_fun <- tbl_summary}
  
  # Define base size statistic to use
  if(whether_survey_data == T){n_statistic <- "{n_unweighted}"} else {n_statistic <- "{n}"}
  
  # Create table
  tbl <- df2 %>%
    summary_fun(
      include = all_of(var_set),
      type = list(unweighted_base ~ "categorical"),
      missing = "no", 
      statistic = list(all_dichotomous() ~ "{p}", 
                        all_categorical() ~ "{p}",
                        unweighted_base ~ n_statistic), 
      digits = list(all_dichotomous() ~ 1)
    ) 
  
    # Confidence intervals. 
  if (ci == TRUE) {
    tbl <- tbl %>% 
      add_ci(
       include = -unweighted_base,
       statistic = list(all_categorical() ~ "[{conf.low} - {conf.high}]"),
       style_fun = all_categorical() ~ label_style_sigfig(scale = 100, digits = 1)
       )
    }
  
  if(!is.null(breaks)){
    suppressWarnings({suppressMessages({
    
     brk_tbls <- map(breaks, 
        ~df2 %>%
          filter(!is.na(.data[[.x]])) %>%
          summary_fun(
            include = all_of(var_set),
            by = all_of(.x),
            type = list(unweighted_base ~ "categorical"),
            missing = "no", 
            statistic = list(all_dichotomous() ~ "{p}", 
                              all_categorical() ~ "{p}",
                              unweighted_base ~ n_statistic), 
            digits = list(all_dichotomous() ~ 1)
          ))
  
    if(sig == TRUE){
      
      brk_tbls <- map(brk_tbls, 
                      ~.x %>% 
          add_p(include = !all_of("unweighted_base"))
        )
    } 
     
    # Confidence intervals. 
    if (ci == TRUE) {
      brk_tbls <- map(brk_tbls, 
        ~.x %>% 
          add_ci(
           include = -unweighted_base,
           statistic = list(all_categorical() ~ "[{conf.low} - {conf.high}]"),
           style_fun = all_categorical() ~ label_style_sigfig(scale = 100, digits = 1)
           )
        )
    }
    
    brk_tbls <- map2(brk_tbls, breaks, 
        ~.x %>%
          modify_spanning_header(
            all_stat_cols() ~ paste0("**",var_label(dataset_reference[[.y]]),"**"),
            # Added to ensure CI + p.value included in spanning headers
            starts_with("ci_stat") | contains("p.value") ~ paste0("**",var_label(dataset_reference[[.y]]),"**"), 
            ) 
        )
     
     tbl <- append(list(tbl), brk_tbls) %>% tbl_merge(tab_spanner = FALSE)
     
    })})
    
  }
  
  # Edit caption when crossbreaks present. 
  if(!is.null(breaks) & is.null(caption)){
      caption <- paste0("Crosstabulation of ", variable_label_stem)
  } else if (is.null(caption)){
    caption <- ""
    }
  
  tbl <- tbl %>%
    
    # Set headers
    modify_header(all_stat_cols() ~ "**{level}**", 
                  label ~ paste0("**",variable_label_stem,"**"), 
                  # stat_0 ~ "**%**"
                  ) %>% 
    
    # Add a caption
    modify_caption(paste0("<div style='text-align: left; font-weight: bold; color: black'>", 
                        caption,
                        "</div>")) 
  
    # Footnote - whether weighted or unweighted
    if(whether_survey_data == T){
           stat_types <- "All statistics shown in this table are weighted."
         } else {stat_types <- "All statistics shown in this table are unweighted."
      }

    tbl <- tbl %>%
      modify_footnote(all_stat_cols() ~ NA) %>% # Suppress standard footnotes
      modify_footnote_header(columns = "label", stat_types, replace = F)

  # Simplify column header when there are no crossbreaks
  if (is.null(breaks)){tbl <- tbl %>% modify_header(starts_with("stat_0") ~ "**%**")}
    
  if(!is.null(breaks)){
    bases_variables <- c("multicode_labels", breaks)
  }
   
    
    if(!is.null(bases)) {
      
      description_of_multicode_variables <- bases[[2]] %>% unique
      names(description_of_multicode_variables) <- "multicode_labels"
      label_of_multicode_variables <- variable_label_stem
      names(label_of_multicode_variables) <- "multicode_labels"

      bases[[2]] <- c(bases[[2]], description_of_multicode_variables)
      bases[[3]] <- c(bases[[3]], label_of_multicode_variables)
      bases[[4]] <- c(bases[[4]], label_of_multicode_variables)
      
      } 
  
  footnotes <- gtsummary_table_notes(
    bases_info = bases, 
    vars = bases_variables, 
    source_note = source, 
    other_footnotes = footnotes
  )

  if (footnotes != ""){
    tbl <- tbl %>% modify_source_note(
    source_note = footnotes, 
    text_interpret = "html")
  }
  
  return(tbl)

  } else {
    
    helpful_error_message <- paste0("Not working: chk1 = ", chk1,", chk2 = ", chk2)
    return(helpful_error_message)
    
  }

}

writeLines(
  c("multicodes <- ", # Assignment needs to be added manually
  deparse(multicodes)), # Extract function code
  paste0(ddir,"/multicodes.R")) # File name is just the function name 


```

<br> 

# Examples {.tabset}

## Example 1

```{r}
multicodes(df = ess3, vars = int_loc, source = "European Social Survey")
```

<br>

## Example 2

```{r}
multicodes(df = ess3, vars = int_loc, ci = T, caption = "Multicoded table caption", footnotes = c("This is what footnotes", "Can look like", "<br>See?")) 
```

<br>

## Example 3

```{r}
multicodes(df = ess3, vars = int_loc, breaks = c("gndr2"), sig =T)

```

<br>

## Example 4

```{r}
multicodes(df = ess3, vars = int_loc, breaks = c("gndr2"), ci = T)
```

<br>

## Example 5

```{r}
multicodes(df = ess3, vars = int_loc, breaks = c("gndr2","pray2"))
```

<br>

## Example 6

```{r}
multicodes(df = ess3, vars = int_loc, breaks = c("gndr2","pray2"), ci =T)
```

#

```{r}

multicodes(df = svy_df, vars = int_loc, breaks = c("gndr2","pray2"), ci = F)

```

<br> 

# Applying base size arguments

```{r}

int_loc

var_descriptions <- rep("Asked of all respondents as well, but with a separate label for testing", 8)
names(var_descriptions) <- int_loc
var_descriptions

example_of_base_information <- base_information(
  data = ess3,
  general_base = "Asked of all respondents", 
  specific_bases = var_descriptions
)

map(example_of_base_information, head)

multicodes(df = ess3, vars = int_loc, breaks = c("gndr2"), ci = F, bases = example_of_base_information)

```















