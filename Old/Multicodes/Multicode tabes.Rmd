---
title: "Multicodes"
output: 
  html_document:  
    toc: true   
    toc_depth: 2  
    toc_float: true
toc-title: "Table of Contents"
---

# Set up

```{r packages, collapse=TRUE}
library(gtsummary)
library(tidyverse)
library(srvyr)
library(flextable)
library(officer)
library(labelled)
library(rlang)
```

<br>

Typical theme for gtsummary()

```{r set theme}

# For all I use the compact theme.
theme_gtsummary_compact()

```

<br>

Load Round 10 UK European Social Survey dataset. 

```{r}

ddir <- "/Users/joecrowley/R/Tables/gtsummary"
load(paste0(ddir,"/ESS_UK_snippet_Round 10.RData"))
glimpse(ess10)

svy_df <- ess10 %>% as_survey_design(weights = anweight)

```

<br>

# Load additional binary data

<br>

The code below loads some additional data, for use in multicoded tables. 

```{r}

load("/Users/joecrowley/R/Data/ESS_UK/ESS_UK_R_data_file.RData")

# Use set of variables on location people can access internet from
ess %>% select(starts_with("acc")) %>% map_df(.,var_label) %>% pivot_longer(cols = everything())

# Identify variable names
int_loc <- ess %>% select(starts_with("acc")) %>% names
int_loc <- int_loc[3:10]
int_loc

ess %>% select(all_of(int_loc)) %>% map_df(.,var_label) %>% pivot_longer(cols = everything())

ess10 %>% select(ctzcntr, brncntr,feethngr) %>% look_for() %>% convert_list_columns_to_character() %>% flextable

```

<br>

# Multicode manual - gtsummary standard

```{r}

bins <- c("ctzcntr", "brncntr","feethngr")
ess10 %>%
  mutate(across(all_of(bins), ~fct_drop(.x))) %>% 
  tbl_summary(
    include = all_of(bins),
    missing = "no", 
    statistic = list(all_dichotomous() ~ "{p}"), 
      digits = list(all_dichotomous() ~ 1)
  ) %>%
  add_stat_label(location = "column") %>% 
  modify_header(all_stat_cols() ~ "**{level}**", 
                label ~ "**Variable**",
                stat_label ~ "")

```

<br>  

# Multicode manual - gtsummary standard improved

Manual code to produce a proper multicode table.

```{r}

ess2 <- 
  ess %>%
  mutate(across(all_of(int_loc), ~as_factor(.x))) %>% 
  mutate(base_size = case_when(!is.na(.data[[int_loc[1]]]) ~ "Unweighted bases", TRUE ~ NA))

ess2 %>% count(base_size, acchome)

var_label(ess2$base_size) <- ""

ess2 %>%
  tbl_summary(
    include = all_of(c(int_loc, "base_size")),
    type = list(all_categorical() ~ "dichotomous", 
                base_size ~ "categorical"),
    value = everything() ~ "Marked",
    missing = "no", 
    statistic = list(all_dichotomous() ~ "{p}", 
                     base_size ~ "{n}"), 
      digits = list(all_dichotomous() ~ 0)
  ) %>%
  modify_header(all_stat_cols() ~ "**{level}**", 
                label ~ paste0("Unweighted percentages"), 
                stat_0 ~ "%")

```

<br> 

# Proper multicode manual

```{r}

ess2 <- 
  ess %>%
  # Factorise variables
  mutate(across(all_of(int_loc), ~as_factor(.x))) %>% 
  # Create base equal to 'Unweighted bases' for all non-missing cases on the outcome variable. 
  mutate(base_size = case_when(!is.na(.data[[int_loc[1]]]) ~ "Unweighted bases", TRUE ~ NA))

# Give unweighted base an empty variable label
var_label(ess2$base_size) <- ""

# Is the number of missing values for each variable the same? 
# TRUE indicates they are the same.
number_of_missing_values_equal <- length(ess2 %>% select(all_of(int_loc)) %>% map_dbl(., ~sum(is.na(.x))) %>% unique) == 1

# Extract list of variable labels
labels <- ess %>% select(all_of(int_loc)) %>% map_chr(.,var_label) 

# Do all strings contain only a single instance of ": "
# FALSE is good, indicates all contain only one instance.
strings_separator <- sum(str_count(labels, ": ") != 1) > 0 

# If above results in FALSE...

# Stems should all be the same, should return FALSE
stems_unique <- length(unique(str_split_i(labels, ": ", 1))) > 1

# If the above results in FALSE...

stems <- vector()
if (stems_unique == F) {
# Remove the variable label stem, relabel variables with unique component of label
for (i in 1:length(int_loc)) {
  stems <- append(stems, str_split_i(
      var_label(ess2[[int_loc[i]]]), 
      ": ", 
      1))
  
  var_label(ess2[[int_loc[i]]]) <- 
    str_split_i(
      var_label(ess2[[int_loc[i]]]), 
      ": ", 
      2)
}

stems <- unique(stems) # Variable label stem...

# Review new variable labels
ess2 %>% select(all_of(int_loc)) %>% map_df(.,var_label) %>% pivot_longer(cols = everything())

} else {
  stems <- ""
}

# Variable levels - should only be two values..
the_levels <- ess2 %>% 
  select(all_of(int_loc)) %>% 
  map(., unique) %>% 
  unlist %>% 
  unique %>% 
  na.omit() %>% 
  as.vector() %>% 
  sort

if (length(the_levels) != 2) {
  print("Problem, variables do not have two levels.")
} else {
  
# If above results in 2, check the values are either 1 and 0 or yes and no. 
values_standard_binaries <- 
  sum(c(tolower(the_levels) %in% c("yes","no"),
      the_levels %in% c("1","0"),
      the_levels %in% c(1,0)))

# Returns zero when they are not standard
if (values_standard_binaries == 0) {
  
  # If above equals zero then... select the first of the values of 'the_levels'
  chosen_level <- the_levels[1] # Chosen level can then be used to select a level to display automatically.
  
  level_reported <- paste0("Percentage refers to proportion who selected '", chosen_level,"'. Unreported category is: '", the_levels[2],"'.")
          
} else if (sum((the_levels) %in% c("yes","no")) == 2) {
  chosen_level <- "yes"
} else if (sum((the_levels) %in% c("Yes","No")) == 2) {
  chosen_level <- "yes"
}  else if (sum((the_levels) %in% c("1","0")) == 2) {
  chosen_level <- "1"
}  else if (sum((the_levels) %in% c(1, 0)) == 2) {
  chosen_level <- 1
}                                                                       

# Continue to table only if variable levels are 
if (number_of_missing_values_equal == TRUE) {
  
ess2 %>%
  tbl_summary(
    include = all_of(c(int_loc, "base_size")),
    type = list(all_categorical() ~ "dichotomous", 
                base_size ~ "categorical"),
    value = everything() ~ chosen_level,
    missing = "no", 
    statistic = list(all_dichotomous() ~ "{p}", 
                     all_categorical() ~ "{p}",
                     base_size ~ "{n}"), 
      digits = list(all_dichotomous() ~ 0)
  ) %>%
  # add_stat_label(location = "column") %>% 
  modify_header(all_stat_cols() ~ "**{level}**", 
                label ~ paste0("**",stems,"**"), 
                stat_0 ~ "%") %>%
  modify_footnote(all_stat_cols() ~ level_reported)
  
} else {
  
  print("Number of missing values not equal for all variables. ")
  
}

}



```

<br>

# Proper multicode function

```{r}

.multi <- function(
    data, # data frame
    outcomes # Vector of variables which identify the outcomes
    ) { 
    
data <- 
  data %>%
  # Create base equal to 'Unweighted bases' for all non-missing cases on the outcome variable. 
  mutate(base_size = case_when(!is.na(.data[[outcomes[1]]]) ~ "Unweighted bases", TRUE ~ NA))

# Give unweighted base an empty variable label
var_label(data$base_size) <- ""

# Is the number of missing values for each variable the same? 
# TRUE indicates they are the same.
number_of_missing_values_equal <- length(data %>% select(all_of(outcomes)) %>% map_dbl(., ~sum(is.na(.x))) %>% unique) == 1

# Extract list of variable labels
labels <- data %>% select(all_of(outcomes)) %>% map_chr(.,var_label) 

# Do all strings contain only a single instance of ": "
# FALSE is good, indicates all contain only one instance.
strings_separator <- sum(str_count(labels, ": ") != 1) > 0 

# If above results in FALSE...

# Stems should all be the same, should return FALSE
stems_unique <- length(unique(str_split_i(labels, ": ", 1))) > 1

# If the above results in FALSE...

stems <- vector()
if (stems_unique == F) {
# Remove the variable label stem, relabel variables with unique component of label
for (i in 1:length(outcomes)) {
  stems <- append(stems, str_split_i(
      var_label(data[[outcomes[i]]]), 
      ": ", 
      1))
  
  var_label(data[[outcomes[i]]]) <- 
    str_split_i(
      var_label(data[[outcomes[i]]]), 
      ": ", 
      2)
}

stems <- unique(stems) # Variable label stem...

# Review new variable labels
data %>% select(all_of(outcomes)) %>% map_df(.,var_label) %>% pivot_longer(cols = everything())

} else {
  stems <- ""
}

# Variable levels - should only be two values..
the_levels <- data %>% 
  select(all_of(outcomes)) %>% 
  map(., unique) %>% 
  unlist %>% 
  unique %>% 
  na.omit() %>% 
  as.vector() %>% 
  sort

if (length(the_levels) != 2) {
  print("Problem, variables do not have two levels.")
} else {

# Ensure all variables have the same two levels and reattach variable labels  
for(yyy in outcomes)  {
retain_label <- var_label(data[yyy])
data <- data %>% mutate(across(all_of(yyy), ~factor(.x, levels = the_levels)))
var_label(data[yyy]) <- retain_label
}
  
# If above results in 2, check the values are either 1 and 0 or yes and no. 
values_standard_binaries <- 
  sum(c(tolower(the_levels) %in% c("yes","no"),
      the_levels %in% c("1","0"),
      the_levels %in% c(1,0)))

# Returns zero when they are not standard
level_reported <- ""
if (values_standard_binaries == 0) {
  
  # If above equals zero then... select the first of the values of 'the_levels'
  chosen_level <- the_levels[1] # Chosen level can then be used to select a level to display automatically.
  
  level_reported <- paste0("Percentage refers to proportion who selected '", chosen_level,"'. Unreported category is: '", the_levels[2],"'.")
          
} else if (sum((the_levels) %in% c("yes","no")) == 2) {
  chosen_level <- "yes"
} else if (sum((the_levels) %in% c("Yes","No")) == 2) {
  chosen_level <- "Yes"
}  else if (sum((the_levels) %in% c("1","0")) == 2) {
  chosen_level <- "1"
}  else if (sum((the_levels) %in% c(1, 0)) == 2) {
  chosen_level <- 1
}                                                                       

# Continue to table only if variable levels are 
if (number_of_missing_values_equal == TRUE) {
  
table <- data %>%
  tbl_summary(
    include = all_of(c(outcomes, "base_size")),
    type = list(all_categorical() ~ "dichotomous", 
                base_size ~ "categorical"),
    value = everything() ~ chosen_level,
    missing = "no", 
    statistic = list(all_dichotomous() ~ "{p}", 
                     all_categorical() ~ "{p}",
                     base_size ~ "{n}"), 
      digits = list(all_dichotomous() ~ 0)
  ) %>%
  # add_stat_label(location = "column") %>% 
  modify_header(all_stat_cols() ~ "**{level}**", 
                label ~ paste0("**",stems,"**"), 
                stat_0 ~ "%") %>%
  modify_footnote(everything() ~ NA)

# Add footnote explaining level reported if is non-standard (e.g. not yes/no etc)
if (level_reported != "") { 
  table <- table %>%
  modify_footnote(all_stat_cols() ~ level_reported)
}
  
} else {
  
  print("Number of missing values not equal for all variables. ")
  
}

}

# return(list(table, the_levels, chosen_level, values_standard_binaries))

return(table)

  }

```

## Function tests...

```{r}

ess %>% 
  mutate(across(all_of(int_loc), ~as_factor(.x))) %>% 
  .multi(outcomes = int_loc)

ess %>% 
  mutate(across(all_of(int_loc), ~as_factor(.x))) %>% 
  mutate(across(all_of(int_loc), ~fct_recode(.x, "Yes" = "Marked", "No" = "Not marked"))) %>% 
  .multi(outcomes = int_loc)

ess %>% 
  mutate(across(all_of(int_loc), ~as_factor(.x))) %>% 
  mutate(across(all_of(int_loc), ~fct_recode(.x, "yes" = "Marked", "no" = "Not marked"))) %>% 
  .multi(outcomes = int_loc)

ess %>% 
  mutate(across(all_of(int_loc), ~as_factor(.x))) %>% 
  mutate(across(all_of(int_loc), ~fct_recode(.x, "1" = "Marked", "0" = "Not marked"))) %>% 
  .multi(outcomes = int_loc)


ess2 <- ess %>% 
  mutate(across(all_of(int_loc), ~as_factor(.x))) %>% 
  mutate(across(all_of(int_loc), ~case_when(.x == "Marked" ~ 1, .x == "Not marked" ~ 0), .names = "{.col}_2")) 

for (x in 1:length(int_loc)) {
  
  var_label(ess2[paste0(int_loc[x], "_2")]) <- var_label(ess[int_loc[x]]) %>% unlist
}

ess2 %>% count(accref_2)
int_loc2 <- paste0(int_loc,"_2")
int_loc2
ess2 %>% .multi(outcomes = int_loc2)

ess %>% 
  mutate(across(all_of(int_loc), ~as_factor(.x))) %>% 
  mutate(across(all_of(int_loc), ~fct_recode(.x, "Selected" = "Marked", "Not selected" = "Not marked"))) %>% 
  .multi(outcomes = int_loc)

```


<br>

```{r}

writeLines(
  c(".multi <- ", # Assignment needs to be added manually
  deparse(.multi)), # Extract function code
  paste0(ddir,"/.multi.R")) # File name is just the function name 

```

<br>

# A simple multicode function

**Some checks**   

 -  all have same base size?
 -  contains splitter in variable labels? (: )  
 -  not contains multiple splitters. 
 
**Steps**. 

1. Checks above,  
2. Relabel variables, store stem
3. Create unweighted base variable,  
4. Create vector of variables to use, 
5. Create table,
6. Optional, add caption, 
7. Optional, add CI. 

```{r vars for simple multicode}

ess %>% select(all_of(int_loc)) %>% look_for(details = "none")

```

<br> 

## Checks

### Bases equal

```{r check all variables have same base size}

unique_base_sizes <- 
  ess %>% 
  select(all_of(int_loc)) %>% 
  map_int(., ~sum(is.na(.x))) %>% 
  unique()

unique_base_sizes

length(unique_base_sizes) == 1

# As function, returns TRUE if equal

bases_equal <- function(
    df, # data frame
    vars # character vector of variables
    ) {
  
  unique_base_sizes <- 
  df %>% 
  select(all_of(vars)) %>% 
  map_int(., ~sum(is.na(.x))) %>% 
  unique()

unique_base_sizes

result <- length(unique_base_sizes) == 1

return(result)

}

bases_equal(ess, int_loc)

```

<br> 

### Labels contain splitter

I combine checks 2 and 3 in the below

```{r check all variable labels contain splitter}

labels_contain_splitter <- 
  ess %>% 
  select(all_of(int_loc)) %>%
  var_label(unlist = T, null_action = "fill") %>% 
  map_int(., ~str_count(.x, ": "))

labels_contain_splitter

# Check each label contains the splitter
length(labels_contain_splitter) == sum(labels_contain_splitter)

# Check no label contains the splitter more than once
max(labels_contain_splitter) == 1

# As a function, returns TRUE if all contain splitter
splitter_present <- function(
    df, 
    vars) { 
  
  labels_contain_splitter <- 
    df %>% 
    select(all_of(vars)) %>%
    var_label(unlist = T, null_action = "fill") %>% 
    map_int(., ~str_count(.x, ": "))

  labels_contain_splitter
  
  # Check each label contains the splitter, returns TRUE if they do
  all_contain_splitter <- length(labels_contain_splitter) == sum(labels_contain_splitter)
  
  # Check no label contains the splitter more than once, returns TRUE all equal 1
  splitter_appears_once_each <- max(labels_contain_splitter) == 1
  
  # result is TRUE if both statements equal true. 
  result <- all_contain_splitter == TRUE & splitter_appears_once_each == TRUE
  return(result)

}

splitter_present(ess, int_loc)

```

<br> 

### Split variable labels and store stem

```{r split variable labels and store stem}

# Testing data frame
ess2 <- ess

# Create a list containing the revised variables
revised_labels_as_list <- 
  map(int_loc, function(xxx) { 
  variable_label <- ess %>% select(all_of(xxx)) %>% var_label %>% str_split_i(., ": ", 2)
  return(variable_label)
}) 
names(revised_labels_as_list) <- int_loc # add names

# Revise variable labels
var_label(ess2) <- revised_labels_as_list

# Review corrected labels...
ess2 %>% 
  select(all_of(int_loc)) %>%
  var_label(unlist = T, null_action = "fill")

# Extract stem - I won't make this a function, it's very simple.
ess %>% pull(int_loc[1]) %>% var_label() %>% str_split_i(., ": ", 1)


# As a function - returns relabelled data frame... 
revise_labels <- function(
    df, # data frame
    vars # character vector of variable names
    ) {
  
  # Create a list containing the revised variables
  revised_labels_as_list <- 
    map(vars, function(xxx) { 
    variable_label <- df %>% select(all_of(xxx)) %>% var_label %>% str_split_i(., ": ", 2)
    return(variable_label)
  }) 
  names(revised_labels_as_list) <- vars # add names

  # Revise variable labels
  var_label(df) <- revised_labels_as_list
  return(df)
  
}

# Apply function
ess2 <- revise_labels(ess, int_loc)

# Review corrected labels...
ess2 %>% 
  select(all_of(int_loc)) %>%
  var_label(unlist = T, null_action = "fill")


```


## Multicode tables function

These functions are just going to expect well managed data. 

You can provide variables which are either:  

- yes / no.  
- 0 / 1.  
- TRUE / FALSE   

All variables **must** have those levels, even if not observed for a particular variable. 

```{r data management}

# Variables must be factors, drop unused levels..
ess3 <- ess %>% 
  mutate(across(all_of(int_loc), ~fct_drop(to_factor(.x))))

# gtsummary expects yes/no, 0/1 or TRUE/FALSE for dichotomous variables
ess3$acchome %>% levels # we have 'Not marked' / 'Marked'
ess3 <- ess3 %>% 
  mutate(across(all_of(int_loc), ~fct_recode(.x, 
        "Yes" = "Marked", "No" = "Not marked")))

ess3$acchome %>% levels

# Note they do all need to have the two levels...
# When adding factor levels remember to use forcats to preserve variable labels
# If done with factor() variable labels will be dropped. 
ess3 %>% select(all_of(int_loc)) %>% map(., levels)
ess3 <- ess3 %>% mutate(across(all_of(int_loc), ~fct_expand(.x, c("Yes", "No")))) 
ess3 %>%  select(all_of(int_loc)) %>% map(., levels)

var_label(ess %>% select(all_of(int_loc)))

# Age
ess3 %>% count(age)
sum(is.na(ess3$age))

ess3 <- ess3 %>% mutate(age30 = fct_drop(to_factor(ageyo30)))
ess3 %>% count(age30)

# Gender
ess3 %>% count(gndr)
sum(is.na(ess3$gndr))

ess3 <- ess3 %>% mutate(gndr2 = fct_drop(to_factor(gndr)))
ess3 %>% count(gndr2)

# Ethnicity
ess3 %>% select(contains("pray"))
ess3 <- ess3 %>% mutate(pray2 = fct_drop(to_factor(pray)))
ess3 %>% count(pray2)
```

<br>

Applying the function itself. 

```{r simple multicode tables function}

.mprop <- function(
    
    df, # data frame 
    vars, # vars
    ci = FALSE, # Confidence intervals, set to TRUE
    caption = "Unweighted percentages", # Replace with caption string
    breaks = NULL # character vector of crossbreaks
    
) {
  
  # Check variable labels contain ": " and that the base of each variable is equal
  chk1 <- splitter_present(df, vars)
  chk2 <- bases_equal(df, vars)
  
  # If both checks are TRUE create table
  if (chk1 == TRUE & chk2 == TRUE) {

  # Add variable reflecting number of non-missing cases
  df <- df %>% mutate(unweighted_base = case_when(!is.na(ess %>% pull(vars[1])) ~ "Unweighted bases", TRUE ~ NA))
  var_label(df$unweighted_base) <- ""

  # Add unweighted base variable to vector of outcomes
  var_set <- c(vars, "unweighted_base")
  
  # Extract variable labels
  variable_label_stem <- df %>% pull(vars[1]) %>% var_label() %>% str_split_i(., ": ", 1)

  # Remove stem from variable labels
  df <- revise_labels(df, vars = vars)

  # Create table
  tbl <- df %>%
    tbl_summary(
      include = all_of(var_set),
      type = list(unweighted_base ~ "categorical"),
      missing = "no", 
      statistic = list(all_dichotomous() ~ "{p}", 
                        all_categorical() ~ "{p}",
                        unweighted_base ~ "{n}"), 
      digits = list(all_dichotomous() ~ 1)
    ) 
  
    # Confidence intervals. 
  if (ci == TRUE) {
    tbl <- tbl %>% 
      add_ci(
       include = -unweighted_base,
       statistic = list(all_categorical() ~ "[{conf.low} - {conf.high}]"),
       style_fun = all_categorical() ~ label_style_sigfig(scale = 100, digits = 1)
       )
    }
  
  if(!is.null(breaks)){
    suppressWarnings({suppressMessages({
    
     brk_tbls <- map(breaks, 
        ~df %>%
          tbl_summary(
            include = all_of(var_set),
            by = all_of(.x),
            type = list(unweighted_base ~ "categorical"),
            missing = "no", 
            statistic = list(all_dichotomous() ~ "{p}", 
                              all_categorical() ~ "{p}",
                              unweighted_base ~ "{n}"), 
            digits = list(all_dichotomous() ~ 1)
          ) %>% 
          add_p(include = !all_of("unweighted_base"))
        ) 
     
       # Confidence intervals. 
    if (ci == TRUE) {
      brk_tbls <- map(brk_tbls, 
        ~.x %>% 
          add_ci(
           include = -unweighted_base,
           statistic = list(all_categorical() ~ "[{conf.low} - {conf.high}]"),
           style_fun = all_categorical() ~ label_style_sigfig(scale = 100, digits = 1)
           )
        )
    }
    
    brk_tbls <- map2(brk_tbls, breaks, 
        ~.x %>%
          modify_spanning_header(
            all_stat_cols() ~ paste0("**",var_label(df[[.y]]),"**"),
            # Added to ensure CI + p.value included in spanning headers
            starts_with("ci_stat") | contains("p.value") ~ paste0("**",var_label(df[[.y]]),"**"), 
            ) 
        )
     
     tbl <- append(list(tbl), brk_tbls) %>% tbl_merge(tab_spanner = FALSE)
     
    })})
    
  }
  
  # Edit caption when crossbreaks present. 
  if(!is.null(breaks) & caption == "Unweighted percentages"){
      caption <- paste0("Crosstabulation of ", variable_label_stem, ". Unweighted percentages.")
    }
  
  tbl <- tbl %>%
    
    # Set headers
    modify_header(all_stat_cols() ~ "**{level}**", 
                  label ~ paste0("**",variable_label_stem,"**"), 
                  # stat_0 ~ "**%**"
                  ) %>% 
    
    # Add a caption
    modify_caption(paste0("<div style='text-align: left; font-weight: bold; color: black'>", 
                        caption,
                        "</div>")) %>% 
    
    # Suppress standard footnotes
    modify_footnote(all_stat_cols() ~ NA)
  
  if (is.null(breaks)){tbl <- tbl %>% modify_header(starts_with("stat_0") ~ "**%**")}
  
  return(tbl)

  } else {
    
    helpful_error_message <- paste0("Not working: chk1 = ", chk1,", chk2 = ", chk2)
    return(helpful_error_message)
    
  }
  
}

.mprop(df = ess3, vars = int_loc)
.mprop(df = ess3, vars = int_loc, ci = T, caption = "Multicoded table caption") 
.mprop(df = ess3, vars = int_loc, breaks = c("gndr2"))
.mprop(df = ess3, vars = int_loc, breaks = c("gndr2"), ci = T)
.mprop(df = ess3, vars = int_loc, breaks = c("gndr2","pray2"))
.mprop(df = ess3, vars = int_loc, breaks = c("gndr2","pray2"), ci =T)


```

```{r}

writeLines(
  c(".mprop <- ", # Assignment needs to be added manually
  deparse(.mprop)), # Extract function code
  paste0(ddir,"/.mprop.R")) # File name is just the function name 

```


